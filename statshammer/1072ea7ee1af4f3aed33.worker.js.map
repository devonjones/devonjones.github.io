{"version":3,"sources":["../1072ea7ee1af4f3aed33.worker.js","../webpack/bootstrap 1072ea7ee1af4f3aed33","workers/stats.worker.js","actions/stats.js","../node_modules/droll/droll.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_toConsumableArray","arr","Array","isArray","arr2","length","from","compareArrays","array1","array2","copyArray","newarr","forEach","a","push","slice","stage_options","aoptions","doptions","stage","newopts","apply","filter","option","retval","opt","type","sum_modifiers","options","modifier","value","recursiveCheckLength","checkPercentages","a1","a2","percentize","aoa","totals","map","reduce","total","num","index","v","Math","round","shots","attacker","attack","attackCountDice","__WEBPACK_IMPORTED_MODULE_1_droll___default","roll","attackCountNumber","roll_with_rerolls","rolls","target","modifiers","k","result","rerollm","roll_with_rerolls_one_fail","reroll1","hits","defender","shot","skill","hit","x","strength","strengthDice","strengthNumber","wounds","str","tough","toughness","wound","calculate_save","defense","save_options","invuln_options","save","ap","invuln","_calculate_save","un","disgustingly_resilient","damage","dr_options","newDam","unsaved","damageDice","damageNumber","damageValues","damageTotals","allocate","damages","curr","kills","dmg","iteration","results","_damage","iterate","testShots","testHits","testWounds","testUnsaved","testDamage","testAllocate","converge","reduceStats","console","log","retresults","reduceResults","meta","iterations","retarr","id","o1","assign","o2","o3","o4","o5","testarr","values","undefined","__WEBPACK_IMPORTED_MODULE_0__actions_stats__","__WEBPACK_IMPORTED_MODULE_1_droll__","self","addEventListener","event","data","postMessage","statsCalculated","stats","STATS_CALCULATED","root","DrollFormula","this","numDice","numSides","minResult","maxResult","avgResult","DrollResult","droll","toString","join","abs","parse","formula","pieces","match","validate","floor","random","b"],"mappings":"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","file":"1072ea7ee1af4f3aed33.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/statshammer/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actions_stats__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_droll__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_droll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_droll__);\nfunction _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}/* eslint \"no-restricted-globals\": 0 */function compareArrays(array1,array2){if(array1.length!==array2.length){return false;}for(var i=0;i<array1.length;i++){if(array1[i]instanceof Array){if(!compareArrays(array1[i],array2[i])){return false;}}else{if(!(array1[i]===array2[i])){return false;}}}return true;}function copyArray(arr){var newarr=[];arr.forEach(function(a){newarr.push(a.slice());});return newarr;}function stage_options(aoptions,doptions,stage){var newopts=[];if(aoptions){newopts.push.apply(newopts,_toConsumableArray(aoptions.filter(function(option){return option.stage===stage;})));}if(doptions){newopts.push.apply(newopts,_toConsumableArray(doptions.filter(function(option){return option.stage===stage;})));}var retval={};newopts.forEach(function(opt){if(\"optid\"in opt){retval[opt.type]=opt;}else{var arr=retval[opt.type];if(!arr){arr=[];}arr.push(opt);retval[opt.type]=arr;}});return retval;}function sum_modifiers(options){var retval=0;if(options.modifier){options.modifier.forEach(function(modifier){retval+=modifier.value;});}return retval;}function recursiveCheckLength(arr){if(arr instanceof Array){if(arr.length===0){return false;}for(var i=0;i<arr.length;i++){var interior=recursiveCheckLength(arr[i]);if(!interior){return false;}}}return true;}function checkPercentages(a1,a2){if(!recursiveCheckLength(a1)){return false;}if(!recursiveCheckLength(a2)){return false;}var pa1=percentize(a1);var pa2=percentize(a2);return compareArrays(pa1,pa2);}function percentize(aoa){var totals=aoa.map(function(arr){return arr.reduce(function(total,num){return total+num;});});var retval=[];aoa.forEach(function(arr,index){retval.push(arr.map(function(v){return Math.round(v/totals[index]*1000)/10;}));});return retval;}// Respond to message from parent thread\nself.addEventListener('message',function(event){var data=event.data;var attacker=data.attacker;var defender=data.defender;var result=iterate(attacker,defender);self.postMessage(Object(__WEBPACK_IMPORTED_MODULE_0__actions_stats__[\"a\" /* statsCalculated */])(result));});function shots(attacker){var shots=attacker.map(function(attack){if(attack.attackCountDice){var roll=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(attack.attackCountDice);return roll.total;}else if(attack.attackCountNumber){return attack.attackCountNumber;}else{return 0;}});return shots;}function roll_with_rerolls(rolls,target,options){var modifiers=sum_modifiers(options);if(\"automatic\"in options){return Array.from({length:rolls},function(v,k){return true;});}return __WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(rolls+'d6').rolls.map(function(roll){if(roll===1){if(\"reroll_one\"in options||\"reroll_missed\"in options){var reroll1=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll('1d6').total;return reroll1+modifiers>=target;}else{return roll+modifiers>=target;}}var result=roll+modifiers>=target;if(!result&&\"reroll_missed\"in options){var rerollm=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll('1d6').total;if(rerollm===1){return false;}return rerollm+modifiers>=target;}else{return result;}});}function roll_with_rerolls_one_fail(rolls,target,options){var modifiers=sum_modifiers(options);if(\"automatic\"in options){return Array.from({length:rolls},function(v,k){return true;});}return __WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(rolls+'d6').rolls.map(function(roll){if(roll===1){if(\"reroll_one\"in options||\"reroll_missed\"in options){var reroll1=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll('1d6').total;if(reroll1===1){return false;}return reroll1+modifiers>=target;}else{return false;}}var result=roll+modifiers>=target;if(!result&&\"reroll_missed\"in options){var rerollm=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll('1d6').total;if(rerollm===1){return false;}return rerollm+modifiers>=target;}else{return result;}});}function hits(attacker,defender,shots){/*\n     Hit Roll:\n     Each time a model makes an attack, roll a dice. If the roll is equal to or\n     greater than the attacking model’s Ballistic Skill characteristic, then it\n     scores a hit with the weapon it is using. If not, the attack fails and the\n     attack sequence ends.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */var hits=shots.map(function(shot,index){if(shot){var options=stage_options(attacker[index].options,defender.options,'hits');return roll_with_rerolls_one_fail(shot,attacker[index].skill,options);}else{return[];}});var hitTotals=hits.map(function(hit){return hit.filter(function(x){return x;}).length;});return hitTotals;}function strength(attack){if(attack.strengthDice){var roll=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(attack.strengthDice);return roll.total;}else if(attack.strengthNumber){return attack.strengthNumber;}else{return 1;}}function wounds(attacker,defender,hits){/*\n        Wound Roll:\n        If an attack scores a hit, you will then need to roll another dice to\n        see if the attack successfully wounds the target. The roll required is\n        determined by comparing the attacking weapon’s Strength characteristic\n        with the target’s Toughness characteristic, as shown on the following\n        table:\n\n        WOUND ROLL\n        ATTACK’S STRENGTH VS TARGET’S TOUGHNESS              D6 ROLL REQUIRED\n        ---------------------------------------------------  ----------------\n        Is the Strength TWICE (or more) than the Toughness?  2+\n        Is the Strength GREATER than the Toughness?          3+\n        Is the Strength EQUAL to the Toughness?              4+\n        Is the Strength LOWER than the Toughness?            5+\n        Is the Strength HALF (or less) than the Toughness?   6+\n\n        If the roll is less than the required number, the attack fails and the\n        attack sequence ends. A roll of 1 always fails, irrespective of any\n        modifiers that may apply.\n    */function target(str,tough){if(str>=tough*2){return 2;}else if(str>tough){return 3;}else if(str===tough){return 4;}else if(str<tough){return 5;}else if(str<tough/2){return 6;}}var wounds=hits.map(function(hit,index){if(hit){var thresh=target(strength(attacker[index]),defender.toughness);var options=stage_options(attacker[index].options,defender.options,'wounds');return roll_with_rerolls_one_fail(hit,thresh,options);}else{return[];}});var woundTotals=wounds.map(function(wound){return wound.filter(function(x){return x;}).length;});return woundTotals;}function calculate_save(defense,attack){var save_options=stage_options(attack.options,defense.options,'saves');var invuln_options=stage_options(attack.options,defense.options,'invulnsaves');var save=defense.save+attack.ap;var invuln=defense.invuln;var target=save;var options=save_options;if(invuln&&invuln+sum_modifiers(save_options)<save+sum_modifiers(invuln_options)){target=invuln;options=invuln_options;}return{target:target,options:options};}function save(attacker,defender,wounds){/*\n     Saving Throw:\n     The player commanding the target unit then makes a saving throw by rolling\n     a dice and modifying the roll by the Armour Penetration characteristic of\n     the weapon that caused the damage. For example, if the weapon has an\n     Armour Penetration of -1, then 1 is subtracted from the saving throw roll.\n     If the result is equal to, or greater than, the Save characteristic of\n     the model the wound was allocated to, then the damage is prevented and the\n     attack sequence ends. If the result is less than the model’s Save\n     characteristic, then the saving throw fails and the model suffers damage.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */var unsaved=wounds.map(function(wound,index){if(wound){var _calculate_save=calculate_save(defender,attacker[index]),target=_calculate_save.target,options=_calculate_save.options;return roll_with_rerolls(wound,target,options).map(function(result){return!result;});}else{return[];}});var unsavedTotals=unsaved.map(function(un){return un.filter(function(x){return x;}).length;});return unsavedTotals;}function disgustingly_resilient(damage,attack,defense,options){if(\"disgustingly_resilient\"in options){var dr_options=stage_options(attack.options,defense.options,'damage_dr');var newDamage=damage.map(function(d){var newDam=0;__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(d+'d6').rolls.forEach(function(roll){if(roll===1&&\"reroll_one\"in dr_options){var reroll1=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll('1d6').total;if(reroll1<options.disgustingly_resilient.value){newDam+=1;}}else if(roll<options.disgustingly_resilient.value){if(\"reroll_missed\"in dr_options){var rerollm=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll('1d6').total;if(rerollm<options.disgustingly_resilient.value){newDam+=1;}}else{newDam+=1;}}});return newDam;});return newDamage;}else{return damage;}}function damage(attacker,defender,unsaved){/*\n     Inflict Damage:\n     The damage inflicted is equal to the Damage characteristic of the weapon\n     used in the attack. A model loses one wound for each point of damage it\n     suffers. If a model’s wounds are reduced to 0, it is either slain or\n     destroyed and removed from play. If a model loses several wounds from a\n     single attack and is destroyed, any excess damage inflicted by that\n     attack is lost and has no effect.\n    */var damage=unsaved.map(function(un,index){var options=stage_options(attacker[index].options,defender.options,'damage');var retval=[];if(un){for(var i=0;i<un;i++){if(attacker[index].damageDice){retval.push(__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(attacker[index].damageDice).total);}else if(attacker[index].damageNumber){retval.push(attacker[index].damageNumber);}}}return disgustingly_resilient(retval,attacker[index],defender,options);});var damageTotal=damage.map(function(d){if(d.length>0){return d.reduce(function(total,num){return total+num;});}else{return 0;}});return{damageValues:damage,damageTotals:damageTotal};}function allocate(attacker,defender,damageValues){var allocate=damageValues.map(function(damages,index){var curr=defender.wounds;var kills=0;damages.forEach(function(dmg){curr-=dmg;if(curr<1){kills+=1;curr=defender.wounds;}});return kills;});return allocate;}function iteration(attacker,defender){var results={};results.shots=shots(attacker);results.hits=hits(attacker,defender,results.shots);results.wounds=wounds(attacker,defender,results.hits);results.unsaved=save(attacker,defender,results.wounds);var _damage=damage(attacker,defender,results.unsaved),damageValues=_damage.damageValues,damageTotals=_damage.damageTotals;results.damage=damageTotals;results.allocate=allocate(attacker,defender,damageValues);return results;}function iterate(attacker,defender){var testShots=attacker.map(function(){return[];});var testHits=attacker.map(function(){return[];});var testWounds=attacker.map(function(){return[];});var testUnsaved=attacker.map(function(){return[];});var testDamage=attacker.map(function(){return[];});var testAllocate=attacker.map(function(){return[];});var converge=false;var i=0;do{var _shots=copyArray(testShots);var _hits=copyArray(testHits);var _wounds=copyArray(testWounds);var unsaved=copyArray(testUnsaved);var _damage2=copyArray(testDamage);var _allocate=copyArray(testAllocate);i++;for(var _i=0;_i<100;_i++){var _result=iteration(attacker,defender);testShots=reduceStats(testShots,_result.shots);testHits=reduceStats(testHits,_result.hits);testWounds=reduceStats(testWounds,_result.wounds);testUnsaved=reduceStats(testUnsaved,_result.unsaved);testDamage=reduceStats(testDamage,_result.damage);testAllocate=reduceStats(testAllocate,_result.allocate);}if(checkPercentages(_shots,testShots)){if(checkPercentages(_hits,testHits)){if(checkPercentages(_wounds,testWounds)){if(checkPercentages(unsaved,testUnsaved)){if(checkPercentages(_damage2,testDamage)){if(checkPercentages(_allocate,testAllocate)){converge=true;}}}}}}}while(!converge);var result={shots:percentize(testShots),hits:percentize(testHits),wounds:percentize(testWounds),unsaved:percentize(testUnsaved),damage:percentize(testDamage),allocate:percentize(testAllocate)};console.log(i*100);var retresults=reduceResults(result,attacker);retresults.meta={iterations:i*100};return retresults;}function reduceResults(results,attacker){var retarr=attacker.map(function(attack){return{id:attack.id+'-stats'};});var shots=results.shots.map(function(shots){return{shots:shots};});var hits=results.hits.map(function(hits){return{hits:hits};});var wounds=results.wounds.map(function(wounds){return{wounds:wounds};});var unsaved=results.unsaved.map(function(un){return{unsaved:un};});var damage=results.damage.map(function(d){return{damage:d};});var allocate=results.allocate.map(function(a){return{allocate:a};});retarr.map(function(o,i){var o1=Object.assign(o,shots[i]);var o2=Object.assign(o1,hits[i]);var o3=Object.assign(o2,wounds[i]);var o4=Object.assign(o3,unsaved[i]);var o5=Object.assign(o4,damage[i]);return Object.assign(o5,allocate[i]);});return retarr;}function reduceStats(testarr,values){var retarr=copyArray(testarr);values.forEach(function(value,index){if(retarr[index][value]===undefined){retarr[index][value]=1;}else{retarr[index][value]+=1;}});return retarr;}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export CALCULATE_STATS */\n/* unused harmony export STATS_CALCULATED */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = statsCalculated;\n/* unused harmony export calculateStats */\nvar CALCULATE_STATS='CALCULATE_STATS';var STATS_CALCULATED='STATS_CALCULATED';function statsCalculated(stats){return{type:STATS_CALCULATED,stats:stats};}function calculateStats(attacker,defender){return{type:CALCULATE_STATS,meta:{WebWorker:true},attacker:attacker,defender:defender};}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n(function(root) {\n\n   \"use strict\";\n\n  var droll = {};\n\n  // Define a \"class\" to represent a formula\n  function DrollFormula() {\n    this.numDice   = 0;\n    this.numSides  = 0;\n    this.modifier  = 0;\n    \n    this.minResult = 0;\n    this.maxResult = 0;\n    this.avgResult = 0;\n  }\n\n  // Define a \"class\" to represent the results of the roll\n  function DrollResult() {\n    this.rolls    = [];\n    this.modifier = 0;\n    this.total    = 0;\n  }\n\n  /**\n   * Returns a string representation of the roll result\n   */\n  DrollResult.prototype.toString = function() {\n    if (this.rolls.length === 1 && this.modifier === 0) {\n      return this.rolls[0] + '';\n    }\n\n    if (this.rolls.length > 1 && this.modifier === 0) {\n      return this.rolls.join(' + ') + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier > 0) {\n      return this.rolls[0] + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier > 0) {\n      return this.rolls.join(' + ') + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier < 0) {\n      return this.rolls[0] + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier < 0) {\n      return this.rolls.join(' + ') + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n  };\n\n  /**\n   * Parse the formula into its component pieces.\n   * Returns a DrollFormula object on success or false on failure.\n   */\n  droll.parse = function(formula) {\n    var pieces = null;\n    var result = new DrollFormula();\n\n    pieces = formula.match(/^([1-9]\\d*)?d([1-9]\\d*)([+-]\\d+)?$/i);\n    if (!pieces) { return false; }\n\n    result.numDice  = (pieces[1] - 0) || 1;\n    result.numSides = (pieces[2] - 0);\n    result.modifier = (pieces[3] - 0) || 0;\n\n    result.minResult = (result.numDice * 1) + result.modifier;\n    result.maxResult = (result.numDice * result.numSides) + result.modifier;\n    result.avgResult = (result.maxResult + result.minResult) / 2;\n\n    return result;\n  };\n\n  /**\n   * Test the validity of the formula.\n   * Returns true on success or false on failure.\n   */\n  droll.validate = function(formula) {\n    return (droll.parse(formula)) ? true : false ;\n  };\n\n  /**\n   * Roll the dice defined by the formula.\n   * Returns a DrollResult object on success or false on failure.\n   */\n  droll.roll = function(formula) {\n    var pieces = null;\n    var result = new DrollResult();\n\n    pieces = droll.parse(formula);\n    if (!pieces) { return false; }\n\n    for (var a=0; a<pieces.numDice; a++) {\n      result.rolls[a] = (1 + Math.floor(Math.random() * pieces.numSides));\n    }\n\n    result.modifier = pieces.modifier;\n\n    for (var b=0; b<result.rolls.length; b++) {\n      result.total += result.rolls[b];\n    }\n    result.total += result.modifier;\n\n    return result;\n  };\n\n  // Export library for use in node.js or browser\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = droll;\n  } else {\n    root.droll = droll;\n  }\n\n}(this));\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 1072ea7ee1af4f3aed33.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/statshammer/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1072ea7ee1af4f3aed33","/* eslint \"no-restricted-globals\": 0 */\nimport { statsCalculated  } from '../actions/stats'\nimport droll from 'droll'\n\nfunction compareArrays(array1, array2) {\n    if(array1.length !== array2.length) {\n        return false\n    }\n    for(let i = 0; i < array1.length; i++) {\n        if(array1[i] instanceof Array) {\n            if (!compareArrays(array1[i], array2[i])) {\n                return false\n            }\n        } else {\n            if(!(array1[i] === array2[i])) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunction copyArray(arr) {\n    let newarr = [];\n    arr.forEach((a) => {\n        newarr.push(a.slice())\n    })\n    return newarr\n}\n\nfunction stage_options(aoptions, doptions, stage) {\n    let newopts = []\n    if(aoptions) {\n        newopts.push(...aoptions.filter((option) => option.stage === stage))\n    }\n    if(doptions)  {\n        newopts.push(...doptions.filter((option) => option.stage === stage))\n    }\n    const retval = {}\n    newopts.forEach((opt) => {\n        if(\"optid\" in opt)  {\n            retval[opt.type] = opt\n        } else {\n            let arr = retval[opt.type]\n            if(!arr) {\n                arr = []\n            }\n            arr.push(opt)\n            retval[opt.type] = arr\n        }\n    })\n    return retval\n}\n\nfunction sum_modifiers(options) {\n    let retval = 0\n    if(options.modifier) {\n        options.modifier.forEach((modifier) => {\n            retval += modifier.value\n        })\n    }\n    return retval\n}\n\nfunction recursiveCheckLength(arr) {\n    if(arr instanceof Array) {\n        if(arr.length === 0) {\n            return false\n        }\n        for(let i = 0; i < arr.length; i++) {\n            const interior = recursiveCheckLength(arr[i])\n            if(!interior) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunction checkPercentages(a1, a2) {\n    if(!recursiveCheckLength(a1)) {\n        return false\n    }\n    if(!recursiveCheckLength(a2)) {\n        return false\n    }\n    const pa1 = percentize(a1)\n    const pa2 = percentize(a2)\n    return compareArrays(pa1, pa2)\n}\nfunction percentize(aoa) {\n    const totals = aoa.map((arr) => arr.reduce((total, num) => total + num))\n\n    let retval = []\n    aoa.forEach((arr, index) => {\n        retval.push(arr.map((v) => {\n            return Math.round(v/totals[index]*1000)/10\n        }))\n    })\n    return retval\n}\n\n// Respond to message from parent thread\nself.addEventListener('message', (event) => {\n    const data = event.data;\n    const attacker = data.attacker\n    const defender = data.defender\n    const result = iterate(attacker, defender)\n    self.postMessage(statsCalculated(result))\n})\n\nfunction shots(attacker) {\n    const shots = attacker.map((attack) => {\n        if(attack.attackCountDice) {\n            const roll = droll.roll(attack.attackCountDice)\n            return roll.total\n        } else if(attack.attackCountNumber) {\n            return attack.attackCountNumber\n        } else {\n            return 0\n        }\n    })\n    return shots\n}\n\nfunction roll_with_rerolls(rolls, target, options) {\n    const modifiers = sum_modifiers(options)\n    if (\"automatic\" in options) {\n        return Array.from({length: rolls}, (v, k) => true)\n    }\n    return droll.roll(`${rolls}d6`).rolls.map((roll) => {\n        if(roll === 1) {\n            if (\"reroll_one\" in options || \"reroll_missed\" in options) {\n                const reroll1 = droll.roll('1d6').total\n                return (reroll1 + modifiers) >= target\n            } else {\n                return (roll + modifiers) >= target\n            }\n        }\n        const result = (roll + modifiers) >= target\n        if(!result && \"reroll_missed\" in options) {\n            const rerollm = droll.roll('1d6').total\n            if(rerollm === 1) {\n                return false\n            }\n            return (rerollm + modifiers) >= target\n        } else {\n            return result\n        }\n    })\n}\n\nfunction roll_with_rerolls_one_fail(rolls, target, options) {\n    const modifiers = sum_modifiers(options)\n    if (\"automatic\" in options) {\n        return Array.from({length: rolls}, (v, k) => true)\n    }\n    return droll.roll(`${rolls}d6`).rolls.map((roll) => {\n        if(roll === 1) {\n            if (\"reroll_one\" in options || \"reroll_missed\" in options) {\n                const reroll1 = droll.roll('1d6').total\n                if(reroll1 === 1) {\n                    return false\n                }\n                return (reroll1 + modifiers) >= target\n            } else {\n                return false\n            }\n        }\n        const result = (roll + modifiers) >= target\n        if(!result && \"reroll_missed\" in options) {\n            const rerollm = droll.roll('1d6').total\n            if(rerollm === 1) {\n                return false\n            }\n            return (rerollm + modifiers) >= target\n        } else {\n            return result\n        }\n    })\n}\n\nfunction hits(attacker, defender, shots) {\n    /*\n     Hit Roll:\n     Each time a model makes an attack, roll a dice. If the roll is equal to or\n     greater than the attacking model’s Ballistic Skill characteristic, then it\n     scores a hit with the weapon it is using. If not, the attack fails and the\n     attack sequence ends.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */\n    const hits = shots.map((shot, index) => {\n        if(shot) {\n            const options = stage_options(attacker[index].options, defender.options, 'hits')\n            return roll_with_rerolls_one_fail(shot, attacker[index].skill, options)\n        } else {\n            return []\n        }\n    })\n    const hitTotals = hits.map((hit) => hit.filter(x => x).length)\n    return hitTotals\n}\n\nfunction strength(attack) {\n    if(attack.strengthDice) {\n        const roll = droll.roll(attack.strengthDice)\n        return roll.total\n    } else if(attack.strengthNumber) {\n        return attack.strengthNumber\n    } else {\n        return 1\n    }\n}\n\nfunction wounds(attacker, defender, hits) {\n    /*\n        Wound Roll:\n        If an attack scores a hit, you will then need to roll another dice to\n        see if the attack successfully wounds the target. The roll required is\n        determined by comparing the attacking weapon’s Strength characteristic\n        with the target’s Toughness characteristic, as shown on the following\n        table:\n\n        WOUND ROLL\n        ATTACK’S STRENGTH VS TARGET’S TOUGHNESS              D6 ROLL REQUIRED\n        ---------------------------------------------------  ----------------\n        Is the Strength TWICE (or more) than the Toughness?  2+\n        Is the Strength GREATER than the Toughness?          3+\n        Is the Strength EQUAL to the Toughness?              4+\n        Is the Strength LOWER than the Toughness?            5+\n        Is the Strength HALF (or less) than the Toughness?   6+\n\n        If the roll is less than the required number, the attack fails and the\n        attack sequence ends. A roll of 1 always fails, irrespective of any\n        modifiers that may apply.\n    */\n    function target(str, tough) {\n        if(str >= tough * 2) {\n            return 2\n        } else if (str > tough) {\n            return 3\n        } else if (str === tough) {\n            return 4\n        } else if (str < tough) {\n            return 5\n        } else if (str < tough/2) {\n            return 6\n        }\n    }\n\n    const wounds = hits.map((hit, index) => {\n        if(hit) {\n            const thresh = target(strength(attacker[index]), defender.toughness)\n            const options = stage_options(attacker[index].options, defender.options, 'wounds')\n            return roll_with_rerolls_one_fail(hit, thresh, options)\n        } else {\n            return []\n        }\n    })\n    const woundTotals = wounds.map((wound) => wound.filter(x => x).length)\n    return woundTotals\n}\n\nfunction calculate_save(defense, attack) {\n    const save_options = stage_options(attack.options, defense.options, 'saves')\n    const invuln_options = stage_options(attack.options, defense.options, 'invulnsaves')\n    const save = defense.save + attack.ap\n    const invuln = defense.invuln\n    let target = save\n    let options = save_options\n    if(invuln && (invuln + sum_modifiers(save_options)) < (save + sum_modifiers(invuln_options))) {\n        target = invuln\n        options = invuln_options\n    }\n    return { target, options }\n}\n\nfunction save(attacker, defender, wounds) {\n    /*\n     Saving Throw:\n     The player commanding the target unit then makes a saving throw by rolling\n     a dice and modifying the roll by the Armour Penetration characteristic of\n     the weapon that caused the damage. For example, if the weapon has an\n     Armour Penetration of -1, then 1 is subtracted from the saving throw roll.\n     If the result is equal to, or greater than, the Save characteristic of\n     the model the wound was allocated to, then the damage is prevented and the\n     attack sequence ends. If the result is less than the model’s Save\n     characteristic, then the saving throw fails and the model suffers damage.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */\n    \n   const unsaved = wounds.map((wound, index) => {\n        if(wound) {\n            const { target, options } = calculate_save(defender, attacker[index])\n            return roll_with_rerolls(wound, target, options).map((result) => !result)\n        } else {\n            return []\n        }\n    })\n    const unsavedTotals = unsaved.map((un) => un.filter(x => x).length)\n    return unsavedTotals\n}\n\nfunction disgustingly_resilient(damage, attack, defense, options) {\n    if(\"disgustingly_resilient\" in options) {\n        const dr_options = stage_options(attack.options, defense.options, 'damage_dr')\n        const newDamage = damage.map((d) => {\n            let newDam = 0;\n            droll.roll(`${d}d6`).rolls.forEach((roll) => {\n                if(roll === 1 && \"reroll_one\" in dr_options) {\n                    const reroll1 = droll.roll(`1d6`).total\n                    if(reroll1 < options.disgustingly_resilient.value) {\n                        newDam += 1\n                    }\n                } else if(roll < options.disgustingly_resilient.value) {\n                    if(\"reroll_missed\" in dr_options) {\n                        const rerollm = droll.roll(`1d6`).total\n                        if(rerollm < options.disgustingly_resilient.value) {\n                            newDam += 1\n                        }\n                    } else {\n                        newDam += 1\n                    }\n                }\n            })\n            return newDam\n        })\n        return newDamage\n    } else {\n        return damage\n    }\n}\n\nfunction damage(attacker, defender, unsaved) {\n    /*\n     Inflict Damage:\n     The damage inflicted is equal to the Damage characteristic of the weapon\n     used in the attack. A model loses one wound for each point of damage it\n     suffers. If a model’s wounds are reduced to 0, it is either slain or\n     destroyed and removed from play. If a model loses several wounds from a\n     single attack and is destroyed, any excess damage inflicted by that\n     attack is lost and has no effect.\n    */\n    const damage = unsaved.map((un, index) => {\n        const options = stage_options(attacker[index].options, defender.options, 'damage')\n        let retval = []\n        if(un) {\n            for(let i = 0; i < un; i++) {\n                if(attacker[index].damageDice) {\n                    retval.push(droll.roll(attacker[index].damageDice).total)\n                } else if(attacker[index].damageNumber) {\n                    retval.push(attacker[index].damageNumber)\n                }\n            }\n        }\n        return disgustingly_resilient(retval, attacker[index], defender, options)\n    })\n    const damageTotal = damage.map((d) => {\n        if (d.length > 0) {\n            return d.reduce((total, num) => total + num)\n        } else {\n            return 0\n        }\n    })\n    return {\n        damageValues: damage,\n        damageTotals: damageTotal\n    }\n}\n\nfunction allocate(attacker, defender, damageValues) {\n    const allocate = damageValues.map((damages, index) => {\n        let curr = defender.wounds\n        let kills = 0\n        damages.forEach((dmg) => {\n            curr -= dmg\n            if(curr < 1) {\n                kills += 1\n                curr = defender.wounds\n            }\n        })\n        return kills\n    })\n    return allocate\n}\n\nfunction iteration(attacker, defender) {\n    let results = {}\n    results.shots = shots(attacker)\n    results.hits = hits(attacker, defender, results.shots)\n    results.wounds = wounds(attacker, defender, results.hits)\n    results.unsaved = save(attacker, defender, results.wounds)\n    const { damageValues, damageTotals } = damage(attacker, defender, results.unsaved)\n    results.damage = damageTotals\n    results.allocate = allocate(attacker, defender, damageValues)\n    return results\n}\n\nfunction iterate(attacker, defender) {\n    let testShots = attacker.map(() => [])\n    let testHits = attacker.map(() => [])\n    let testWounds = attacker.map(() => [])\n    let testUnsaved = attacker.map(() => [])\n    let testDamage = attacker.map(() => [])\n    let testAllocate = attacker.map(() => [])\n    let converge = false\n    let i = 0;\n    do {\n        let shots = copyArray(testShots)\n        let hits = copyArray(testHits)\n        let wounds = copyArray(testWounds)\n        let unsaved = copyArray(testUnsaved)\n        let damage = copyArray(testDamage)\n        let allocate = copyArray(testAllocate)\n        i++\n        for(let i = 0; i < 100; i++) {\n            const result = iteration(attacker, defender)\n            testShots = reduceStats(testShots, result.shots)\n            testHits = reduceStats(testHits, result.hits)\n            testWounds = reduceStats(testWounds, result.wounds)\n            testUnsaved = reduceStats(testUnsaved, result.unsaved)\n            testDamage = reduceStats(testDamage, result.damage)\n            testAllocate = reduceStats(testAllocate, result.allocate)\n        }\n        if(checkPercentages(shots, testShots)) {\n            if(checkPercentages(hits, testHits)) {\n                if(checkPercentages(wounds, testWounds)) {\n                    if(checkPercentages(unsaved, testUnsaved)) {\n                        if(checkPercentages(damage, testDamage)) {\n                            if(checkPercentages(allocate, testAllocate)) {\n                                converge = true\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } while (!converge)\n    const result = {\n        shots: percentize(testShots),\n        hits: percentize(testHits),\n        wounds: percentize(testWounds),\n        unsaved: percentize(testUnsaved),\n        damage: percentize(testDamage),\n        allocate: percentize(testAllocate)\n    }\n    console.log(i*100)\n    const retresults = reduceResults(result, attacker)\n    retresults.meta = {iterations: i*100}\n    return retresults\n}\n\nfunction reduceResults(results, attacker) {\n    const retarr = attacker.map((attack) => { return {id: `${attack.id}-stats`}})\n    const shots = results.shots.map((shots) => { return {shots: shots}})\n    const hits = results.hits.map((hits) => { return {hits: hits}})\n    const wounds = results.wounds.map((wounds) => { return {wounds: wounds}})\n    const unsaved = results.unsaved.map((un) => { return {unsaved: un}})\n    const damage = results.damage.map((d) => { return {damage: d}})\n    const allocate = results.allocate.map((a) => { return {allocate: a}})\n    retarr.map((o, i) => {\n        let o1 = Object.assign(o, shots[i])\n        let o2 = Object.assign(o1, hits[i])\n        let o3 = Object.assign(o2, wounds[i])\n        let o4 = Object.assign(o3, unsaved[i])\n        let o5 = Object.assign(o4, damage[i])\n        return Object.assign(o5, allocate[i])\n    })\n    return retarr\n}\n\nfunction reduceStats(testarr, values) {\n    let retarr = copyArray(testarr)\n    values.forEach((value, index) => {\n        if(retarr[index][value] === undefined) {\n            retarr[index][value] = 1\n        } else {\n            retarr[index][value] += 1\n        }\n    })\n    return retarr\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/workers/stats.worker.js","export const CALCULATE_STATS = 'CALCULATE_STATS'\nexport const STATS_CALCULATED = 'STATS_CALCULATED'\n\nexport function statsCalculated(stats) {\n    return {\n        type: STATS_CALCULATED,\n        stats\n    }\n}\n\nexport function calculateStats(attacker, defender) {\n    return {\n        type: CALCULATE_STATS,\n        meta: {\n            WebWorker: true\n        },\n        attacker,\n        defender\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/stats.js","(function(root) {\n\n   \"use strict\";\n\n  var droll = {};\n\n  // Define a \"class\" to represent a formula\n  function DrollFormula() {\n    this.numDice   = 0;\n    this.numSides  = 0;\n    this.modifier  = 0;\n    \n    this.minResult = 0;\n    this.maxResult = 0;\n    this.avgResult = 0;\n  }\n\n  // Define a \"class\" to represent the results of the roll\n  function DrollResult() {\n    this.rolls    = [];\n    this.modifier = 0;\n    this.total    = 0;\n  }\n\n  /**\n   * Returns a string representation of the roll result\n   */\n  DrollResult.prototype.toString = function() {\n    if (this.rolls.length === 1 && this.modifier === 0) {\n      return this.rolls[0] + '';\n    }\n\n    if (this.rolls.length > 1 && this.modifier === 0) {\n      return this.rolls.join(' + ') + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier > 0) {\n      return this.rolls[0] + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier > 0) {\n      return this.rolls.join(' + ') + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier < 0) {\n      return this.rolls[0] + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier < 0) {\n      return this.rolls.join(' + ') + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n  };\n\n  /**\n   * Parse the formula into its component pieces.\n   * Returns a DrollFormula object on success or false on failure.\n   */\n  droll.parse = function(formula) {\n    var pieces = null;\n    var result = new DrollFormula();\n\n    pieces = formula.match(/^([1-9]\\d*)?d([1-9]\\d*)([+-]\\d+)?$/i);\n    if (!pieces) { return false; }\n\n    result.numDice  = (pieces[1] - 0) || 1;\n    result.numSides = (pieces[2] - 0);\n    result.modifier = (pieces[3] - 0) || 0;\n\n    result.minResult = (result.numDice * 1) + result.modifier;\n    result.maxResult = (result.numDice * result.numSides) + result.modifier;\n    result.avgResult = (result.maxResult + result.minResult) / 2;\n\n    return result;\n  };\n\n  /**\n   * Test the validity of the formula.\n   * Returns true on success or false on failure.\n   */\n  droll.validate = function(formula) {\n    return (droll.parse(formula)) ? true : false ;\n  };\n\n  /**\n   * Roll the dice defined by the formula.\n   * Returns a DrollResult object on success or false on failure.\n   */\n  droll.roll = function(formula) {\n    var pieces = null;\n    var result = new DrollResult();\n\n    pieces = droll.parse(formula);\n    if (!pieces) { return false; }\n\n    for (var a=0; a<pieces.numDice; a++) {\n      result.rolls[a] = (1 + Math.floor(Math.random() * pieces.numSides));\n    }\n\n    result.modifier = pieces.modifier;\n\n    for (var b=0; b<result.rolls.length; b++) {\n      result.total += result.rolls[b];\n    }\n    result.total += result.modifier;\n\n    return result;\n  };\n\n  // Export library for use in node.js or browser\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = droll;\n  } else {\n    root.droll = droll;\n  }\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/droll/droll.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}