{"version":3,"sources":["../3f2f78397d252fc9b484.worker.js","../webpack/bootstrap 3f2f78397d252fc9b484","workers/stats.worker.js","actions/stats.js","../node_modules/droll/droll.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","compareArrays","array1","array2","length","Array","copyArray","arr","newarr","forEach","a","push","slice","recursiveCheckLength","checkPercentages","a1","a2","percentize","aoa","totals","map","reduce","total","num","retval","index","v","Math","round","shots","attacker","attack","attackCountDice","__WEBPACK_IMPORTED_MODULE_1_droll___default","roll","attackCountNumber","hits","defender","shot","rolls","skill","hit","filter","x","strength","strengthDice","strengthNumber","wounds","target","str","tough","thresh","toughness","wound","save","ap","invuln","un","damage","unsaved","damageDice","damageNumber","damageValues","damageTotals","allocate","damages","curr","kills","dmg","iteration","results","_damage","iterate","testShots","testHits","testWounds","testUnsaved","testDamage","testAllocate","converge","result","reduceStats","console","log","retresults","reduceResults","meta","iterations","retarr","id","o1","assign","o2","o3","o4","o5","testarr","values","value","undefined","__WEBPACK_IMPORTED_MODULE_0__actions_stats__","__WEBPACK_IMPORTED_MODULE_1_droll__","self","addEventListener","event","data","postMessage","statsCalculated","stats","type","STATS_CALCULATED","root","DrollFormula","this","numDice","numSides","modifier","minResult","maxResult","avgResult","DrollResult","droll","toString","join","abs","parse","formula","pieces","match","validate","floor","random","b"],"mappings":"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","file":"3f2f78397d252fc9b484.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/statshammer/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__actions_stats__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_droll__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_droll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_droll__);\n/* eslint \"no-restricted-globals\": 0 */function compareArrays(array1,array2){if(array1.length!==array2.length){return false;}for(var i=0;i<array1.length;i++){if(array1[i]instanceof Array){if(!compareArrays(array1[i],array2[i])){return false;}}else{if(!(array1[i]===array2[i])){return false;}}}return true;}function copyArray(arr){var newarr=[];arr.forEach(function(a){newarr.push(a.slice());});return newarr;}function recursiveCheckLength(arr){if(arr instanceof Array){if(arr.length===0){return false;}for(var i=0;i<arr.length;i++){var interior=recursiveCheckLength(arr[i]);if(!interior){return false;}}}return true;}function checkPercentages(a1,a2){if(!recursiveCheckLength(a1)){return false;}if(!recursiveCheckLength(a2)){return false;}var pa1=percentize(a1);var pa2=percentize(a2);return compareArrays(pa1,pa2);}function percentize(aoa){var totals=aoa.map(function(arr){return arr.reduce(function(total,num){return total+num;});});var retval=[];aoa.forEach(function(arr,index){retval.push(arr.map(function(v){return Math.round(v/totals[index]*1000)/10;}));});return retval;}// Respond to message from parent thread\nself.addEventListener('message',function(event){var data=event.data;var attacker=data.attacker;var defender=data.defender;var result=iterate(attacker,defender);self.postMessage(Object(__WEBPACK_IMPORTED_MODULE_0__actions_stats__[\"a\" /* statsCalculated */])(result));});function shots(attacker){var shots=attacker.map(function(attack){if(attack.attackCountDice){var roll=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(attack.attackCountDice);return roll.total;}else if(attack.attackCountNumber){return attack.attackCountNumber;}else{return 0;}});return shots;}function hits(attacker,defender,shots){/*\n     Hit Roll:\n     Each time a model makes an attack, roll a dice. If the roll is equal to or\n     greater than the attacking model’s Ballistic Skill characteristic, then it\n     scores a hit with the weapon it is using. If not, the attack fails and the\n     attack sequence ends.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */var hits=shots.map(function(shot,index){if(shot){return __WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(shot+'d6').rolls.map(function(roll){if(roll===1){return false;}return roll>=attacker[index].skill;});}else{return[];}});var hitTotals=hits.map(function(hit){return hit.filter(function(x){return x;}).length;});return hitTotals;}function strength(attack){if(attack.strengthDice){var roll=__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(attack.strengthDice);return roll.total;}else if(attack.strengthNumber){return attack.strengthNumber;}else{return 1;}}function wounds(attacker,defender,hits){/*\n        Wound Roll:\n        If an attack scores a hit, you will then need to roll another dice to\n        see if the attack successfully wounds the target. The roll required is\n        determined by comparing the attacking weapon’s Strength characteristic\n        with the target’s Toughness characteristic, as shown on the following\n        table:\n\n        WOUND ROLL\n        ATTACK’S STRENGTH VS TARGET’S TOUGHNESS              D6 ROLL REQUIRED\n        ---------------------------------------------------  ----------------\n        Is the Strength TWICE (or more) than the Toughness?  2+\n        Is the Strength GREATER than the Toughness?          3+\n        Is the Strength EQUAL to the Toughness?              4+\n        Is the Strength LOWER than the Toughness?            5+\n        Is the Strength HALF (or less) than the Toughness?   6+\n\n        If the roll is less than the required number, the attack fails and the\n        attack sequence ends. A roll of 1 always fails, irrespective of any\n        modifiers that may apply.\n    */function target(str,tough){if(str>=tough*2){return 2;}else if(str>tough){return 3;}else if(str===tough){return 4;}else if(str<tough){return 5;}else if(str<tough/2){return 6;}}var wounds=hits.map(function(hit,index){if(hit){return __WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(hit+'d6').rolls.map(function(roll){if(defender){var thresh=target(strength(attacker[index]),defender.toughness);if(roll===1){return false;}return roll>=thresh;}else{return\"\";}});}else{return[];}});var woundTotals=wounds.map(function(wound){return wound.filter(function(x){return x;}).length;});return woundTotals;}function save(attacker,defender,wounds){/*\n     Saving Throw:\n     The player commanding the target unit then makes a saving throw by rolling\n     a dice and modifying the roll by the Armour Penetration characteristic of\n     the weapon that caused the damage. For example, if the weapon has an\n     Armour Penetration of -1, then 1 is subtracted from the saving throw roll.\n     If the result is equal to, or greater than, the Save characteristic of\n     the model the wound was allocated to, then the damage is prevented and the\n     attack sequence ends. If the result is less than the model’s Save\n     characteristic, then the saving throw fails and the model suffers damage.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */var unsaved=wounds.map(function(wound,index){if(wound){return __WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(wound+'d6').rolls.map(function(roll){if(roll===1){return true;}var save=defender.save+attacker[index].ap;var invuln=defender.invuln;var target=save;if(invuln&&invuln<save){target=invuln;}return roll<target;});}else{return[];}});var unsavedTotals=unsaved.map(function(un){return un.filter(function(x){return x;}).length;});return unsavedTotals;}function damage(attacker,defender,unsaved){/*\n     Inflict Damage:\n     The damage inflicted is equal to the Damage characteristic of the weapon\n     used in the attack. A model loses one wound for each point of damage it\n     suffers. If a model’s wounds are reduced to 0, it is either slain or\n     destroyed and removed from play. If a model loses several wounds from a\n     single attack and is destroyed, any excess damage inflicted by that\n     attack is lost and has no effect.\n    */var damage=unsaved.map(function(un,index){var retval=[];if(un){for(var i=0;i<un;i++){if(attacker[index].damageDice){retval.push(__WEBPACK_IMPORTED_MODULE_1_droll___default.a.roll(attacker[index].damageDice).total);}else if(attacker[index].damageNumber){retval.push(attacker[index].damageNumber);}}}return retval;});var damageTotal=damage.map(function(d){if(d.length>0){return d.reduce(function(total,num){return total+num;});}else{return 0;}});return{damageValues:damage,damageTotals:damageTotal};}function allocate(attacker,defender,damageValues){var allocate=damageValues.map(function(damages,index){var curr=defender.wounds;var kills=0;damages.forEach(function(dmg){curr-=dmg;if(curr<1){kills+=1;curr=defender.wounds;}});return kills;});return allocate;}function iteration(attacker,defender){var results={};results.shots=shots(attacker);results.hits=hits(attacker,defender,results.shots);results.wounds=wounds(attacker,defender,results.hits);results.unsaved=save(attacker,defender,results.wounds);var _damage=damage(attacker,defender,results.unsaved),damageValues=_damage.damageValues,damageTotals=_damage.damageTotals;results.damage=damageTotals;results.allocate=allocate(attacker,defender,damageValues);return results;}function iterate(attacker,defender){var testShots=attacker.map(function(){return[];});var testHits=attacker.map(function(){return[];});var testWounds=attacker.map(function(){return[];});var testUnsaved=attacker.map(function(){return[];});var testDamage=attacker.map(function(){return[];});var testAllocate=attacker.map(function(){return[];});var converge=false;var i=0;do{var _shots=copyArray(testShots);var _hits=copyArray(testHits);var _wounds=copyArray(testWounds);var unsaved=copyArray(testUnsaved);var _damage2=copyArray(testDamage);var _allocate=copyArray(testAllocate);i++;for(var _i=0;_i<100;_i++){var _result=iteration(attacker,defender);testShots=reduceStats(testShots,_result.shots);testHits=reduceStats(testHits,_result.hits);testWounds=reduceStats(testWounds,_result.wounds);testUnsaved=reduceStats(testUnsaved,_result.unsaved);testDamage=reduceStats(testDamage,_result.damage);testAllocate=reduceStats(testAllocate,_result.allocate);}if(checkPercentages(_shots,testShots)){if(checkPercentages(_hits,testHits)){if(checkPercentages(_wounds,testWounds)){if(checkPercentages(unsaved,testUnsaved)){if(checkPercentages(_damage2,testDamage)){if(checkPercentages(_allocate,testAllocate)){converge=true;}}}}}}}while(!converge);var result={shots:percentize(testShots),hits:percentize(testHits),wounds:percentize(testWounds),unsaved:percentize(testUnsaved),damage:percentize(testDamage),allocate:percentize(testAllocate)};console.log(i*100);var retresults=reduceResults(result,attacker);retresults.meta={iterations:i*100};return retresults;}function reduceResults(results,attacker){var retarr=attacker.map(function(attack){return{id:attack.id+'-stats'};});var shots=results.shots.map(function(shots){return{shots:shots};});var hits=results.hits.map(function(hits){return{hits:hits};});var wounds=results.wounds.map(function(wounds){return{wounds:wounds};});var unsaved=results.unsaved.map(function(un){return{unsaved:un};});var damage=results.damage.map(function(d){return{damage:d};});var allocate=results.allocate.map(function(a){return{allocate:a};});retarr.map(function(o,i){var o1=Object.assign(o,shots[i]);var o2=Object.assign(o1,hits[i]);var o3=Object.assign(o2,wounds[i]);var o4=Object.assign(o3,unsaved[i]);var o5=Object.assign(o4,damage[i]);return Object.assign(o5,allocate[i]);});return retarr;}function reduceStats(testarr,values){var retarr=copyArray(testarr);values.forEach(function(value,index){if(retarr[index][value]===undefined){retarr[index][value]=1;}else{retarr[index][value]+=1;}});return retarr;}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export CALCULATE_STATS */\n/* unused harmony export STATS_CALCULATED */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = statsCalculated;\n/* unused harmony export calculateStats */\nvar CALCULATE_STATS='CALCULATE_STATS';var STATS_CALCULATED='STATS_CALCULATED';function statsCalculated(stats){return{type:STATS_CALCULATED,stats:stats};}function calculateStats(attacker,defender){return{type:CALCULATE_STATS,meta:{WebWorker:true},attacker:attacker,defender:defender};}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n(function(root) {\n\n   \"use strict\";\n\n  var droll = {};\n\n  // Define a \"class\" to represent a formula\n  function DrollFormula() {\n    this.numDice   = 0;\n    this.numSides  = 0;\n    this.modifier  = 0;\n    \n    this.minResult = 0;\n    this.maxResult = 0;\n    this.avgResult = 0;\n  }\n\n  // Define a \"class\" to represent the results of the roll\n  function DrollResult() {\n    this.rolls    = [];\n    this.modifier = 0;\n    this.total    = 0;\n  }\n\n  /**\n   * Returns a string representation of the roll result\n   */\n  DrollResult.prototype.toString = function() {\n    if (this.rolls.length === 1 && this.modifier === 0) {\n      return this.rolls[0] + '';\n    }\n\n    if (this.rolls.length > 1 && this.modifier === 0) {\n      return this.rolls.join(' + ') + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier > 0) {\n      return this.rolls[0] + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier > 0) {\n      return this.rolls.join(' + ') + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier < 0) {\n      return this.rolls[0] + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier < 0) {\n      return this.rolls.join(' + ') + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n  };\n\n  /**\n   * Parse the formula into its component pieces.\n   * Returns a DrollFormula object on success or false on failure.\n   */\n  droll.parse = function(formula) {\n    var pieces = null;\n    var result = new DrollFormula();\n\n    pieces = formula.match(/^([1-9]\\d*)?d([1-9]\\d*)([+-]\\d+)?$/i);\n    if (!pieces) { return false; }\n\n    result.numDice  = (pieces[1] - 0) || 1;\n    result.numSides = (pieces[2] - 0);\n    result.modifier = (pieces[3] - 0) || 0;\n\n    result.minResult = (result.numDice * 1) + result.modifier;\n    result.maxResult = (result.numDice * result.numSides) + result.modifier;\n    result.avgResult = (result.maxResult + result.minResult) / 2;\n\n    return result;\n  };\n\n  /**\n   * Test the validity of the formula.\n   * Returns true on success or false on failure.\n   */\n  droll.validate = function(formula) {\n    return (droll.parse(formula)) ? true : false ;\n  };\n\n  /**\n   * Roll the dice defined by the formula.\n   * Returns a DrollResult object on success or false on failure.\n   */\n  droll.roll = function(formula) {\n    var pieces = null;\n    var result = new DrollResult();\n\n    pieces = droll.parse(formula);\n    if (!pieces) { return false; }\n\n    for (var a=0; a<pieces.numDice; a++) {\n      result.rolls[a] = (1 + Math.floor(Math.random() * pieces.numSides));\n    }\n\n    result.modifier = pieces.modifier;\n\n    for (var b=0; b<result.rolls.length; b++) {\n      result.total += result.rolls[b];\n    }\n    result.total += result.modifier;\n\n    return result;\n  };\n\n  // Export library for use in node.js or browser\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = droll;\n  } else {\n    root.droll = droll;\n  }\n\n}(this));\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 3f2f78397d252fc9b484.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/statshammer/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3f2f78397d252fc9b484","/* eslint \"no-restricted-globals\": 0 */\nimport { statsCalculated  } from '../actions/stats'\nimport droll from 'droll'\n\nfunction compareArrays(array1, array2) {\n    if(array1.length !== array2.length) {\n        return false\n    }\n    for(let i = 0; i < array1.length; i++) {\n        if(array1[i] instanceof Array) {\n            if (!compareArrays(array1[i], array2[i])) {\n                return false\n            }\n        } else {\n            if(!(array1[i] === array2[i])) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunction copyArray(arr) {\n    let newarr = [];\n    arr.forEach((a) => {\n        newarr.push(a.slice())\n    })\n    return newarr\n}\n\nfunction recursiveCheckLength(arr) {\n    if(arr instanceof Array) {\n        if(arr.length === 0) {\n            return false\n        }\n        for(let i = 0; i < arr.length; i++) {\n            const interior = recursiveCheckLength(arr[i])\n            if(!interior) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunction checkPercentages(a1, a2) {\n    if(!recursiveCheckLength(a1)) {\n        return false\n    }\n    if(!recursiveCheckLength(a2)) {\n        return false\n    }\n    const pa1 = percentize(a1)\n    const pa2 = percentize(a2)\n    return compareArrays(pa1, pa2)\n}\nfunction percentize(aoa) {\n    const totals = aoa.map((arr) => arr.reduce((total, num) => total + num))\n\n    let retval = []\n    aoa.forEach((arr, index) => {\n        retval.push(arr.map((v) => {\n            return Math.round(v/totals[index]*1000)/10\n        }))\n    })\n    return retval\n}\n\n// Respond to message from parent thread\nself.addEventListener('message', (event) => {\n    const data = event.data;\n    const attacker = data.attacker\n    const defender = data.defender\n    const result = iterate(attacker, defender)\n    self.postMessage(statsCalculated(result))\n})\n\nfunction shots(attacker) {\n    const shots = attacker.map((attack) => {\n        if(attack.attackCountDice) {\n            const roll = droll.roll(attack.attackCountDice)\n            return roll.total\n        } else if(attack.attackCountNumber) {\n            return attack.attackCountNumber\n        } else {\n            return 0\n        }\n    })\n    return shots\n}\n\nfunction hits(attacker, defender, shots) {\n    /*\n     Hit Roll:\n     Each time a model makes an attack, roll a dice. If the roll is equal to or\n     greater than the attacking model’s Ballistic Skill characteristic, then it\n     scores a hit with the weapon it is using. If not, the attack fails and the\n     attack sequence ends.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */\n    const hits = shots.map((shot, index) => {\n        if(shot) {\n            return droll.roll(`${shot}d6`).rolls.map((roll) => {\n                if(roll === 1) {\n                    return false\n                }\n                return roll >= attacker[index].skill\n            })\n        } else {\n            return []\n        }\n    })\n    const hitTotals = hits.map((hit) => hit.filter(x => x).length)\n    return hitTotals\n}\n\nfunction strength(attack) {\n    if(attack.strengthDice) {\n        const roll = droll.roll(attack.strengthDice)\n        return roll.total\n    } else if(attack.strengthNumber) {\n        return attack.strengthNumber\n    } else {\n        return 1\n    }\n}\n\nfunction wounds(attacker, defender, hits) {\n    /*\n        Wound Roll:\n        If an attack scores a hit, you will then need to roll another dice to\n        see if the attack successfully wounds the target. The roll required is\n        determined by comparing the attacking weapon’s Strength characteristic\n        with the target’s Toughness characteristic, as shown on the following\n        table:\n\n        WOUND ROLL\n        ATTACK’S STRENGTH VS TARGET’S TOUGHNESS              D6 ROLL REQUIRED\n        ---------------------------------------------------  ----------------\n        Is the Strength TWICE (or more) than the Toughness?  2+\n        Is the Strength GREATER than the Toughness?          3+\n        Is the Strength EQUAL to the Toughness?              4+\n        Is the Strength LOWER than the Toughness?            5+\n        Is the Strength HALF (or less) than the Toughness?   6+\n\n        If the roll is less than the required number, the attack fails and the\n        attack sequence ends. A roll of 1 always fails, irrespective of any\n        modifiers that may apply.\n    */\n    function target(str, tough) {\n        if(str >= tough * 2) {\n            return 2\n        } else if (str > tough) {\n            return 3\n        } else if (str === tough) {\n            return 4\n        } else if (str < tough) {\n            return 5\n        } else if (str < tough/2) {\n            return 6\n        }\n    }\n\n    const wounds = hits.map((hit, index) => {\n        if(hit) {\n            return droll.roll(`${hit}d6`).rolls.map((roll) => {\n                if(defender) {\n                    const thresh = target(strength(attacker[index]), defender.toughness)\n                    if (roll === 1) {\n                        return false\n                    }\n                    return roll >= thresh\n                } else {\n                    return \"\"\n                }\n            })\n        } else {\n            return []\n        }\n    })\n    const woundTotals = wounds.map((wound) => wound.filter(x => x).length)\n    return woundTotals\n}\n\nfunction save(attacker, defender, wounds) {\n    /*\n     Saving Throw:\n     The player commanding the target unit then makes a saving throw by rolling\n     a dice and modifying the roll by the Armour Penetration characteristic of\n     the weapon that caused the damage. For example, if the weapon has an\n     Armour Penetration of -1, then 1 is subtracted from the saving throw roll.\n     If the result is equal to, or greater than, the Save characteristic of\n     the model the wound was allocated to, then the damage is prevented and the\n     attack sequence ends. If the result is less than the model’s Save\n     characteristic, then the saving throw fails and the model suffers damage.\n     A roll of 1 always fails, irrespective of any modifiers that may apply.\n    */\n    \n   const unsaved = wounds.map((wound, index) => {\n        if(wound) {\n            return droll.roll(`${wound}d6`).rolls.map((roll) => {\n                if(roll === 1) {\n                    return true\n                }\n                const save = defender.save + attacker[index].ap\n                const invuln = defender.invuln\n                let target = save\n                if(invuln && invuln < save) {\n                    target = invuln\n                }\n                return roll < target\n            })\n        } else {\n            return []\n        }\n    })\n    const unsavedTotals = unsaved.map((un) => un.filter(x => x).length)\n    return unsavedTotals\n}\n\nfunction damage(attacker, defender, unsaved) {\n    /*\n     Inflict Damage:\n     The damage inflicted is equal to the Damage characteristic of the weapon\n     used in the attack. A model loses one wound for each point of damage it\n     suffers. If a model’s wounds are reduced to 0, it is either slain or\n     destroyed and removed from play. If a model loses several wounds from a\n     single attack and is destroyed, any excess damage inflicted by that\n     attack is lost and has no effect.\n    */\n    const damage = unsaved.map((un, index) => {\n        let retval = []\n        if(un) {\n            for(let i = 0; i < un; i++) {\n                if(attacker[index].damageDice) {\n                    retval.push(droll.roll(attacker[index].damageDice).total)\n                } else if(attacker[index].damageNumber) {\n                    retval.push(attacker[index].damageNumber)\n                }\n            }\n        }\n        return retval\n    })\n    const damageTotal = damage.map((d) => {\n        if (d.length > 0) {\n            return d.reduce((total, num) => total + num)\n        } else {\n            return 0\n        }\n    })\n    return {\n        damageValues: damage,\n        damageTotals: damageTotal\n    }\n}\n\nfunction allocate(attacker, defender, damageValues) {\n    const allocate = damageValues.map((damages, index) => {\n        let curr = defender.wounds\n        let kills = 0\n        damages.forEach((dmg) => {\n            curr -= dmg\n            if(curr < 1) {\n                kills += 1\n                curr = defender.wounds\n            }\n        })\n        return kills\n    })\n    return allocate\n}\n\nfunction iteration(attacker, defender) {\n    let results = {}\n    results.shots = shots(attacker)\n    results.hits = hits(attacker, defender, results.shots)\n    results.wounds = wounds(attacker, defender, results.hits)\n    results.unsaved = save(attacker, defender, results.wounds)\n    const { damageValues, damageTotals } = damage(attacker, defender, results.unsaved)\n    results.damage = damageTotals\n    results.allocate = allocate(attacker, defender, damageValues)\n    return results\n}\n\nfunction iterate(attacker, defender) {\n    let testShots = attacker.map(() => [])\n    let testHits = attacker.map(() => [])\n    let testWounds = attacker.map(() => [])\n    let testUnsaved = attacker.map(() => [])\n    let testDamage = attacker.map(() => [])\n    let testAllocate = attacker.map(() => [])\n    let converge = false\n    let i = 0;\n    do {\n        let shots = copyArray(testShots)\n        let hits = copyArray(testHits)\n        let wounds = copyArray(testWounds)\n        let unsaved = copyArray(testUnsaved)\n        let damage = copyArray(testDamage)\n        let allocate = copyArray(testAllocate)\n        i++\n        for(let i = 0; i < 100; i++) {\n            const result = iteration(attacker, defender)\n            testShots = reduceStats(testShots, result.shots)\n            testHits = reduceStats(testHits, result.hits)\n            testWounds = reduceStats(testWounds, result.wounds)\n            testUnsaved = reduceStats(testUnsaved, result.unsaved)\n            testDamage = reduceStats(testDamage, result.damage)\n            testAllocate = reduceStats(testAllocate, result.allocate)\n        }\n        if(checkPercentages(shots, testShots)) {\n            if(checkPercentages(hits, testHits)) {\n                if(checkPercentages(wounds, testWounds)) {\n                    if(checkPercentages(unsaved, testUnsaved)) {\n                        if(checkPercentages(damage, testDamage)) {\n                            if(checkPercentages(allocate, testAllocate)) {\n                                converge = true\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } while (!converge)\n    const result = {\n        shots: percentize(testShots),\n        hits: percentize(testHits),\n        wounds: percentize(testWounds),\n        unsaved: percentize(testUnsaved),\n        damage: percentize(testDamage),\n        allocate: percentize(testAllocate)\n    }\n    console.log(i*100)\n    const retresults = reduceResults(result, attacker)\n    retresults.meta = {iterations: i*100}\n    return retresults\n}\n\nfunction reduceResults(results, attacker) {\n    const retarr = attacker.map((attack) => { return {id: `${attack.id}-stats`}})\n    const shots = results.shots.map((shots) => { return {shots: shots}})\n    const hits = results.hits.map((hits) => { return {hits: hits}})\n    const wounds = results.wounds.map((wounds) => { return {wounds: wounds}})\n    const unsaved = results.unsaved.map((un) => { return {unsaved: un}})\n    const damage = results.damage.map((d) => { return {damage: d}})\n    const allocate = results.allocate.map((a) => { return {allocate: a}})\n    retarr.map((o, i) => {\n        let o1 = Object.assign(o, shots[i])\n        let o2 = Object.assign(o1, hits[i])\n        let o3 = Object.assign(o2, wounds[i])\n        let o4 = Object.assign(o3, unsaved[i])\n        let o5 = Object.assign(o4, damage[i])\n        return Object.assign(o5, allocate[i])\n    })\n    return retarr\n}\n\nfunction reduceStats(testarr, values) {\n    let retarr = copyArray(testarr)\n    values.forEach((value, index) => {\n        if(retarr[index][value] === undefined) {\n            retarr[index][value] = 1\n        } else {\n            retarr[index][value] += 1\n        }\n    })\n    return retarr\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/workers/stats.worker.js","export const CALCULATE_STATS = 'CALCULATE_STATS'\nexport const STATS_CALCULATED = 'STATS_CALCULATED'\n\nexport function statsCalculated(stats) {\n    return {\n        type: STATS_CALCULATED,\n        stats\n    }\n}\n\nexport function calculateStats(attacker, defender) {\n    return {\n        type: CALCULATE_STATS,\n        meta: {\n            WebWorker: true\n        },\n        attacker,\n        defender\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/stats.js","(function(root) {\n\n   \"use strict\";\n\n  var droll = {};\n\n  // Define a \"class\" to represent a formula\n  function DrollFormula() {\n    this.numDice   = 0;\n    this.numSides  = 0;\n    this.modifier  = 0;\n    \n    this.minResult = 0;\n    this.maxResult = 0;\n    this.avgResult = 0;\n  }\n\n  // Define a \"class\" to represent the results of the roll\n  function DrollResult() {\n    this.rolls    = [];\n    this.modifier = 0;\n    this.total    = 0;\n  }\n\n  /**\n   * Returns a string representation of the roll result\n   */\n  DrollResult.prototype.toString = function() {\n    if (this.rolls.length === 1 && this.modifier === 0) {\n      return this.rolls[0] + '';\n    }\n\n    if (this.rolls.length > 1 && this.modifier === 0) {\n      return this.rolls.join(' + ') + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier > 0) {\n      return this.rolls[0] + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier > 0) {\n      return this.rolls.join(' + ') + ' + ' + this.modifier + ' = ' + this.total;\n    }\n\n    if (this.rolls.length === 1 && this.modifier < 0) {\n      return this.rolls[0] + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n\n    if (this.rolls.length > 1 && this.modifier < 0) {\n      return this.rolls.join(' + ') + ' - ' + Math.abs(this.modifier) + ' = ' + this.total;\n    }\n  };\n\n  /**\n   * Parse the formula into its component pieces.\n   * Returns a DrollFormula object on success or false on failure.\n   */\n  droll.parse = function(formula) {\n    var pieces = null;\n    var result = new DrollFormula();\n\n    pieces = formula.match(/^([1-9]\\d*)?d([1-9]\\d*)([+-]\\d+)?$/i);\n    if (!pieces) { return false; }\n\n    result.numDice  = (pieces[1] - 0) || 1;\n    result.numSides = (pieces[2] - 0);\n    result.modifier = (pieces[3] - 0) || 0;\n\n    result.minResult = (result.numDice * 1) + result.modifier;\n    result.maxResult = (result.numDice * result.numSides) + result.modifier;\n    result.avgResult = (result.maxResult + result.minResult) / 2;\n\n    return result;\n  };\n\n  /**\n   * Test the validity of the formula.\n   * Returns true on success or false on failure.\n   */\n  droll.validate = function(formula) {\n    return (droll.parse(formula)) ? true : false ;\n  };\n\n  /**\n   * Roll the dice defined by the formula.\n   * Returns a DrollResult object on success or false on failure.\n   */\n  droll.roll = function(formula) {\n    var pieces = null;\n    var result = new DrollResult();\n\n    pieces = droll.parse(formula);\n    if (!pieces) { return false; }\n\n    for (var a=0; a<pieces.numDice; a++) {\n      result.rolls[a] = (1 + Math.floor(Math.random() * pieces.numSides));\n    }\n\n    result.modifier = pieces.modifier;\n\n    for (var b=0; b<result.rolls.length; b++) {\n      result.total += result.rolls[b];\n    }\n    result.total += result.modifier;\n\n    return result;\n  };\n\n  // Export library for use in node.js or browser\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = droll;\n  } else {\n    root.droll = droll;\n  }\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/droll/droll.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}